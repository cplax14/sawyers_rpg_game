/**
 * Comprehensive Save System Manager
 * Orchestrates local storage, cloud sync, validation, and save operations
 */

import { v4 as uuidv4 } from 'uuid';
import {
  SaveGameData,
  SaveSlotInfo,
  SaveMetadata,
  SavePlayerSummary,
  SaveProgressSummary,
  SaveOperationOptions,
  LoadOperationOptions,
  SaveSystemConfig,
  SaveOperationResult,
  SaveSystemEvents,
  SaveExportOptions,
  SaveImportResult,
  SaveSyncStatus
} from '../types/saveSystem';
import { ReactGameState } from '../types/game';
import { IndexedDbManager } from './indexedDbManager';

export class SaveSystemManager {
  private indexedDbManager: IndexedDbManager;
  private config: SaveSystemConfig;
  private events: SaveSystemEvents;
  private isInitialized = false;

  constructor(config: SaveSystemConfig, events: SaveSystemEvents = {}) {
    this.config = config;
    this.events = events;
    this.indexedDbManager = new IndexedDbManager(config);
  }

  /**
   * Initialize the save system
   */
  async initialize(): Promise<SaveOperationResult<void>> {
    try {
      const dbResult = await this.indexedDbManager.initialize();
      if (!dbResult.success) {
        return dbResult;
      }

      // Migrate legacy saves if they exist
      await this.migrateLegacySaves();

      // Perform cleanup
      await this.indexedDbManager.cleanup();

      this.isInitialized = true;
      return { success: true };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Save system initialization failed')
      };
    }
  }

  /**
   * Save current game state to specified slot
   */
  async saveGame(
    gameState: ReactGameState,
    options: SaveOperationOptions
  ): Promise<SaveOperationResult<SaveGameData>> {
    if (!this.isInitialized) {
      return {
        success: false,
        error: new Error('Save system not initialized')
      };
    }

    const { slotNumber, saveName, onProgress } = options;

    try {
      this.events.onSaveStarted?.(slotNumber, saveName || `Save ${slotNumber + 1}`);

      onProgress?.(0, 'Preparing save data...');

      // Generate save metadata
      const metadata = this.generateSaveMetadata(slotNumber, saveName, gameState);

      // Generate player and progress summaries
      const playerSummary = this.generatePlayerSummary(gameState);
      const progressSummary = this.generateProgressSummary(gameState);

      onProgress?.(20, 'Creating save package...');

      // Create save data package
      const saveData: SaveGameData = {
        gameState,
        metadata,
        playerSummary,
        progressSummary,
        checksum: '', // Will be generated by IndexedDbManager
        isCompressed: this.config.compressionEnabled
      };

      // Add screenshot if enabled
      if (options.includeScreenshot && this.config.screenshotsEnabled) {
        onProgress?.(30, 'Capturing screenshot...');
        metadata.thumbnail = await this.captureScreenshot();
      }

      onProgress?.(40, 'Saving to local storage...');

      // Save to IndexedDB
      const saveResult = await this.indexedDbManager.saveToSlot(
        slotNumber,
        saveData,
        (progress, status) => onProgress?.(40 + progress * 0.4, status)
      );

      if (!saveResult.success) {
        this.events.onSaveError?.(saveResult.error!, slotNumber);
        return saveResult;
      }

      onProgress?.(80, 'Syncing to cloud...');

      // Cloud sync if enabled
      if (options.syncToCloud && this.config.cloudSyncEnabled) {
        // TODO: Implement cloud sync
        onProgress?.(90, 'Cloud sync completed');
      }

      onProgress?.(100, 'Save completed');

      this.events.onSaveCompleted?.(slotNumber, saveResult.data!);

      return saveResult;

    } catch (error) {
      const err = error instanceof Error ? error : new Error('Unknown save error');
      this.events.onSaveError?.(err, slotNumber);
      return {
        success: false,
        error: err
      };
    }
  }

  /**
   * Load game state from specified slot
   */
  async loadGame(
    options: LoadOperationOptions
  ): Promise<SaveOperationResult<SaveGameData>> {
    if (!this.isInitialized) {
      return {
        success: false,
        error: new Error('Save system not initialized')
      };
    }

    const { slotNumber, onProgress } = options;

    try {
      this.events.onLoadStarted?.(slotNumber);

      onProgress?.(0, 'Loading save data...');

      // Load from IndexedDB
      const loadResult = await this.indexedDbManager.loadFromSlot(
        slotNumber,
        (progress, status) => onProgress?.(progress, status)
      );

      if (!loadResult.success) {
        // Try cloud fallback if enabled
        if (options.fallbackToCloud && this.config.cloudSyncEnabled) {
          onProgress?.(50, 'Attempting cloud fallback...');
          // TODO: Implement cloud fallback
        }

        this.events.onLoadError?.(loadResult.error!, slotNumber);
        return loadResult;
      }

      onProgress?.(100, 'Load completed');

      this.events.onLoadCompleted?.(slotNumber, loadResult.data!);

      return loadResult;

    } catch (error) {
      const err = error instanceof Error ? error : new Error('Unknown load error');
      this.events.onLoadError?.(err, slotNumber);
      return {
        success: false,
        error: err
      };
    }
  }

  /**
   * Delete save from specified slot
   */
  async deleteSave(slotNumber: number): Promise<SaveOperationResult<void>> {
    if (!this.isInitialized) {
      return {
        success: false,
        error: new Error('Save system not initialized')
      };
    }

    return await this.indexedDbManager.deleteSlot(slotNumber);
  }

  /**
   * Get information about all save slots
   */
  async getAllSaves(): Promise<SaveOperationResult<SaveSlotInfo[]>> {
    if (!this.isInitialized) {
      return {
        success: false,
        error: new Error('Save system not initialized')
      };
    }

    return await this.indexedDbManager.getAllSlotInfo();
  }

  /**
   * Export save data to file
   */
  async exportSave(
    slotNumber: number,
    options: SaveExportOptions
  ): Promise<SaveOperationResult<Blob>> {
    try {
      const loadResult = await this.indexedDbManager.loadFromSlot(slotNumber);

      if (!loadResult.success) {
        return {
          success: false,
          error: loadResult.error
        };
      }

      const saveData = loadResult.data!;
      let exportData: any = saveData;

      // Process based on export format
      switch (options.format) {
        case 'json':
          exportData = JSON.stringify(saveData, null, 2);
          break;
        case 'binary':
          exportData = this.serializeToBinary(saveData);
          break;
        case 'legacy':
          exportData = this.convertToLegacyFormat(saveData);
          break;
      }

      // Create blob
      const blob = new Blob([exportData], {
        type: options.format === 'json' ? 'application/json' : 'application/octet-stream'
      });

      return {
        success: true,
        data: blob
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Export failed')
      };
    }
  }

  /**
   * Import save data from file
   */
  async importSave(
    file: File,
    targetSlot: number
  ): Promise<SaveImportResult> {
    try {
      const text = await file.text();
      let saveData: SaveGameData;
      let sourceFormat: 'json' | 'binary' | 'legacy' | 'unknown' = 'unknown';

      // Detect format and parse
      try {
        // Try JSON first
        const jsonData = JSON.parse(text);
        if (this.isValidSaveFormat(jsonData)) {
          saveData = jsonData;
          sourceFormat = 'json';
        } else if (this.isLegacyFormat(jsonData)) {
          saveData = this.convertFromLegacyFormat(jsonData);
          sourceFormat = 'legacy';
        } else {
          throw new Error('Unrecognized JSON format');
        }
      } catch {
        // Try binary format
        try {
          saveData = this.deserializeFromBinary(text);
          sourceFormat = 'binary';
        } catch {
          return {
            success: false,
            errors: ['Could not parse save file format'],
            warnings: [],
            sourceFormat: 'unknown'
          };
        }
      }

      // Update metadata for new slot
      saveData.metadata.id = uuidv4();
      saveData.metadata.slotNumber = targetSlot;
      saveData.metadata.lastModified = new Date();

      // Save to target slot
      const saveResult = await this.indexedDbManager.saveToSlot(targetSlot, saveData);

      return {
        success: saveResult.success,
        saveData: saveResult.success ? saveData : undefined,
        errors: saveResult.success ? [] : [saveResult.error?.message || 'Import failed'],
        warnings: [],
        sourceFormat
      };

    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : 'Unknown import error'],
        warnings: [],
        sourceFormat: 'unknown'
      };
    }
  }

  /**
   * Get storage usage information
   */
  async getStorageInfo(): Promise<SaveOperationResult<{
    used: number;
    available: number;
    total: number;
    quotaPercentage: number;
  }>> {
    const quotaResult = await this.indexedDbManager.getStorageQuota();

    if (!quotaResult.success) {
      return quotaResult as any;
    }

    const { used, available, total } = quotaResult.data!;
    const quotaPercentage = total > 0 ? (used / total) * 100 : 0;

    // Check for quota warnings
    if (quotaPercentage > 80) {
      this.events.onQuotaWarning?.(quotaPercentage);
    }
    if (quotaPercentage > 95) {
      this.events.onQuotaExceeded?.();
    }

    return {
      success: true,
      data: {
        used,
        available,
        total,
        quotaPercentage
      }
    };
  }

  /**
   * Cleanup and optimize save system
   */
  async cleanup(): Promise<SaveOperationResult<{deletedCount: number, reclaimedBytes: number}>> {
    return await this.indexedDbManager.cleanup();
  }

  /**
   * Close save system and clean up resources
   */
  close(): void {
    this.indexedDbManager.close();
    this.isInitialized = false;
  }

  // Private helper methods

  private generateSaveMetadata(
    slotNumber: number,
    saveName: string | undefined,
    gameState: ReactGameState
  ): SaveMetadata {
    const now = new Date();

    return {
      id: uuidv4(),
      slotNumber,
      name: saveName || `Save ${slotNumber + 1}`,
      createdAt: now,
      lastModified: now,
      lastAccessed: now,
      gameVersion: '1.0.0', // TODO: Get from package.json
      saveVersion: '1.0.0',
      totalPlayTime: 0, // TODO: Calculate from game state
      fileSizeBytes: 0, // Will be calculated during save
      tags: [],
      isFavorite: false,
      isCorrupted: false
    };
  }

  private generatePlayerSummary(gameState: ReactGameState): SavePlayerSummary {
    const player = gameState.player;

    // Get data from new experience system if available
    const experienceData = gameState.experience?.level;
    const creatureData = gameState.creatures;
    const inventoryData = gameState.inventoryState;

    return {
      name: player?.name || 'Unknown',
      class: player?.class || 'Unknown',
      level: experienceData?.currentLevel || player?.level || 1,
      hp: player?.hp || 0,
      maxHp: player?.maxHp || 0,
      experience: experienceData?.totalExperience || player?.experience || 0,
      gold: player?.gold || 0,
      currentAreaName: gameState.currentArea || 'Unknown',
      questsCompleted: gameState.completedQuests?.length || 0,
      monstersCaptured: creatureData?.totalCaptured || gameState.capturedMonsters?.length || 0,
      achievementsUnlocked: gameState.experience?.achievements?.filter(a => a.completed).length || 0
    };
  }

  private generateProgressSummary(gameState: ReactGameState): SaveProgressSummary {
    const inventoryData = gameState.inventoryState;
    const creatureData = gameState.creatures;
    const experienceData = gameState.experience;

    // Calculate completion metrics from new systems
    const totalItems = inventoryData?.totalItems || gameState.inventory?.length || 0;
    const uniqueCreatures = Object.keys(creatureData?.bestiary || {}).length;
    const totalCreatures = creatureData?.totalDiscovered || 0;
    const totalExperience = experienceData?.level?.totalExperience || 0;

    return {
      overallCompletion: this.calculateOverallCompletion(gameState),
      storyCompletion: this.calculateStoryCompletion(gameState),
      areasDiscovered: gameState.unlockedAreas?.length || 0,
      totalAreas: 20, // TODO: Get from game data
      uniqueMonstersEncountered: uniqueCreatures,
      itemsCollected: totalItems,
      deathCount: 0, // TODO: Track in game state
      saveCount: 1
    };
  }

  private calculateOverallCompletion(gameState: ReactGameState): number {
    // Simple completion calculation based on multiple factors
    let totalWeight = 0;
    let completedWeight = 0;

    // Story progression (weight: 40%)
    const storyWeight = 40;
    const storyCompletion = this.calculateStoryCompletion(gameState);
    totalWeight += storyWeight;
    completedWeight += (storyCompletion / 100) * storyWeight;

    // Area discovery (weight: 20%)
    const areaWeight = 20;
    const areasDiscovered = gameState.unlockedAreas?.length || 0;
    const totalAreas = 20; // TODO: Get from game data
    const areaCompletion = Math.min(100, (areasDiscovered / totalAreas) * 100);
    totalWeight += areaWeight;
    completedWeight += (areaCompletion / 100) * areaWeight;

    // Creature collection (weight: 20%)
    if (gameState.creatures) {
      const creatureWeight = 20;
      const creatureCompletion = gameState.creatures.completionPercentage || 0;
      totalWeight += creatureWeight;
      completedWeight += (creatureCompletion / 100) * creatureWeight;
    }

    // Level progression (weight: 20%)
    const levelWeight = 20;
    const currentLevel = gameState.experience?.level?.currentLevel || gameState.player?.level || 1;
    const maxLevel = 100; // TODO: Get from game configuration
    const levelCompletion = Math.min(100, (currentLevel / maxLevel) * 100);
    totalWeight += levelWeight;
    completedWeight += (levelCompletion / 100) * levelWeight;

    return totalWeight > 0 ? Math.round((completedWeight / totalWeight) * 100) : 0;
  }

  private calculateStoryCompletion(gameState: ReactGameState): number {
    // Simple story completion based on completed quests
    const completedQuests = gameState.completedQuests?.length || 0;
    const totalQuests = 50; // TODO: Get from game data
    return Math.min(100, (completedQuests / totalQuests) * 100);
  }

  private async captureScreenshot(): Promise<string> {
    // Simple screenshot capture - in production you'd want a more sophisticated approach
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('Cannot create canvas context');

      canvas.width = 400;
      canvas.height = 300;

      // Fill with a placeholder color
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add some text
      ctx.fillStyle = '#d4af37';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText("Sawyer's RPG", canvas.width / 2, canvas.height / 2);

      return canvas.toDataURL('image/png');
    } catch {
      return ''; // Return empty string if screenshot fails
    }
  }

  private async migrateLegacySaves(): Promise<void> {
    // Check for legacy localStorage saves and migrate them
    try {
      const legacyKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith('sawyers_rpg_save_')) {
          legacyKeys.push(key);
        }
      }

      // Migrate each legacy save
      for (const key of legacyKeys) {
        const legacyData = localStorage.getItem(key);
        if (legacyData) {
          try {
            const parsed = JSON.parse(legacyData);
            const slotNumber = parseInt(key.replace('sawyers_rpg_save_', ''));

            if (!isNaN(slotNumber)) {
              const migratedData = this.convertFromLegacyFormat(parsed);
              await this.indexedDbManager.saveToSlot(slotNumber, migratedData);

              // Remove legacy save
              localStorage.removeItem(key);
            }
          } catch (error) {
            console.warn(`Failed to migrate legacy save ${key}:`, error);
          }
        }
      }
    } catch (error) {
      console.warn('Legacy save migration failed:', error);
    }
  }

  private isValidSaveFormat(data: any): boolean {
    return data &&
           typeof data === 'object' &&
           data.metadata &&
           data.gameState &&
           data.playerSummary &&
           data.progressSummary;
  }

  private isLegacyFormat(data: any): boolean {
    // Check if this looks like old save format
    return data &&
           typeof data === 'object' &&
           data.player &&
           !data.metadata;
  }

  private convertFromLegacyFormat(legacyData: any): SaveGameData {
    // Convert legacy save format to new format
    // This is a simplified conversion - in practice you'd handle all the complex mapping

    const gameState: ReactGameState = {
      player: legacyData.player || null,
      currentArea: legacyData.currentArea || 'starting_village',
      unlockedAreas: legacyData.unlockedAreas || ['starting_village'],
      inventory: legacyData.inventory || [],
      capturedMonsters: legacyData.monsters || [],
      completedQuests: legacyData.completedQuests || [],
      storyFlags: legacyData.storyFlags || {},
      settings: legacyData.settings || {},
      saveSlots: [],
      currentSaveSlot: null,
      currentScreen: 'menu',
      isLoading: false,
      error: null,
      sessionStartTime: Date.now(),
      totalPlayTime: legacyData.totalPlayTime || 0,
      currentEncounter: null,
      // Initialize new inventory system states to undefined
      // They will be populated when the respective hooks are first used
      inventoryState: undefined,
      creatures: undefined,
      experience: undefined
    };

    const metadata = this.generateSaveMetadata(0, 'Migrated Save', gameState);
    const playerSummary = this.generatePlayerSummary(gameState);
    const progressSummary = this.generateProgressSummary(gameState);

    return {
      gameState,
      metadata,
      playerSummary,
      progressSummary,
      checksum: '',
      isCompressed: false
    };
  }

  private convertToLegacyFormat(saveData: SaveGameData): string {
    // Convert new format back to legacy for compatibility
    const legacyData = {
      player: saveData.gameState.player,
      currentArea: saveData.gameState.currentArea,
      unlockedAreas: saveData.gameState.unlockedAreas,
      inventory: saveData.gameState.inventory,
      monsters: saveData.gameState.capturedMonsters,
      completedQuests: saveData.gameState.completedQuests,
      storyFlags: saveData.gameState.storyFlags,
      settings: saveData.gameState.settings
    };

    return JSON.stringify(legacyData, null, 2);
  }

  private serializeToBinary(data: SaveGameData): ArrayBuffer {
    // Simple binary serialization - in production use a proper serialization library
    const jsonString = JSON.stringify(data);
    const encoder = new TextEncoder();
    return encoder.encode(jsonString).buffer;
  }

  private deserializeFromBinary(data: string): SaveGameData {
    // Simple binary deserialization
    const decoder = new TextDecoder();
    const uint8Array = new Uint8Array(data.split(',').map(num => parseInt(num)));
    const jsonString = decoder.decode(uint8Array);
    return JSON.parse(jsonString);
  }
}

// Create default configuration
export const createDefaultSaveSystemConfig = (): SaveSystemConfig => ({
  maxSaveSlots: 10,
  maxSaveFileSizeMB: 50,
  autoSaveEnabled: true,
  autoSaveIntervalMinutes: 5,
  cloudSyncEnabled: false, // Disabled by default until implementation
  cloudSyncOptions: {
    autoSync: false,
    syncInterval: 60,
    syncOnStart: false,
    syncOnSave: false,
    conflictResolution: 'ask_user'
  },
  compressionEnabled: true,
  screenshotsEnabled: true,
  localStorageQuotaMB: 100
});